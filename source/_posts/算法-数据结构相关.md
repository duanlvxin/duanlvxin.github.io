---
title: 算法-数据结构相关
date: 2024-08-24 14:19:10
categories:
  - 数据结构与算法
tags:
  - js
  - 算法
cover: https://assets.leetcode.cn/aliyun-lc-upload/uploaded_files/2021/03/73c9f099-abbe-4d94-853f-f8abffd459cd/leetcode.png
---

## 实现一个LRU缓存
```js
class LRUCache {
  constructor(maxLen = 3) {
    this.queue = []
    this.maxLen = maxLen
  }

  push(val) {
    let currentLen = this.queue.length
    // 如果当前长度+1<=maxLen，那么不需要去除，把queue里最早的那个val去除，在最后面插入
    let index = this.queue.findIndex((item)=>item===val)
    if(currentLen + 1 <= maxLen) {
      if(index!==-1){
        this.queue.splice(index,1)
      }
      this.queue.push(val)
    } else { // 否则，如果queue中存在这个值，那么去除；否则，淘汰第一个；在最后面插入
      if(index!==-1) {
        this.queue.splice(index,1)
      }else{
        this.queue.shift()
      }
      this.queue.push(val)
    }
  }

  get(val){
    let index = this.queue.findIndex((item)=>item===val)
    if(index === -1) return -1
    // 找到的这个值，需要更新位置到最后面（最新鲜）
    this.queue.splice(index, 1)
    this.queue.push(val)
    return val
  }
}
```

## 求环状链表
双指针(https://leetcode.cn/problems/linked-list-cycle/)
```js
var hasCycle = function(head) {
    let p1 = head
    let p2 = head

    while(p1!==null && p2!==null) {
        p1 = p1.next
        if(p2.next === null) {
            return false
        }
        p2 = p2.next.next
        if(p1===p2) {
            return true
        }
    }

    return false
};
```

## 二叉树的前序、中序、后序遍历
```js
function preTraverse(root, callback) {
  if(!root) return

  callback(root)
  preTraverse(root.left)
  preTraverse(root.right)
}
```

```js
function midTraverse(root, callback) {
  if(!root) return

  preTraverse(root.left)
  callback(root)
  preTraverse(root.right)
}
```

```js
function postTraverse(root, callback) {
  if(!root) return

  preTraverse(root.left)
  preTraverse(root.right)
  callback(root)
}
```

## 树的层序遍历

```js
function traverse(root, callback) {
  if(!root) return

  let queue = [root]
  while(queue.length) {
    let node = queue.shift()
    traverse(node)

    if(node.children) {
      node.children.forEach((item)=>{
        queue.push(item)
      })
    }
  }
}
```

题目：https://leetcode.cn/problems/binary-tree-level-order-traversal/description/
```js
var levelOrder = function(root) {
    if(!root) return [];

    let queue = [root];
    let res = [];
    while(queue.length) {
        let len = queue.length; // 这一层有几个节点
        let temp = []; // 存储这一层的节点
        while(len) {
           let node = queue.shift();
           len--
           temp.push(node.val);
           // 下一层的节点
           if(node.left) {
            queue.push(node.left)
           }
           if(node.right) {
            queue.push(node.right)
           }
        }
        // 把这一层节点放入结果中
        res.push(temp);
    }

    return res;
};
```

## 获取二叉树的层级
```js
function deepth(root) {
  if(!root) return 0;
  return Math.max(deepth(root.left), deepth(root.right)) + 1;
}
```

## 实现类数组转数组

```js
[...arguments]
Array.from(arguments)
Array.prototype.slice.call(arguments)
Array.prototype.splice.call(arguments, 0)
Array.prototype.concat.apply([], arguments)
Array.apply([], arguments)
```

## 实现DOM转JSON

## 实现JSON转DOM

## 实现树转数组

## 实现数组转树

## 实现对象打平
