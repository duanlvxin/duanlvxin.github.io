---
title: 算法-数据结构相关
date: 2024-08-24 14:19:10
categories:
  - 数据结构与算法
tags:
  - js
  - 算法
cover: https://assets.leetcode.cn/aliyun-lc-upload/uploaded_files/2021/03/73c9f099-abbe-4d94-853f-f8abffd459cd/leetcode.png
---

## 实现一个LRU缓存
```js
const lru = new LRUCache(2)
lru.push(1)
lru.push(2) // [1,2]
console.log(lru.get(1)) // [2,1], 打印1

lru.push(3,3) // [1,3]
console.log(lru.get(2)) // 打印-1
lru.push(4,4) // [3,4]
console.log(lru.get(1)) // -1
```

```js
class LRUCache {
  constructor(maxLen = 3) {
    this.queue = []
    this.maxLen = maxLen
  }

  push(val) {
    let currentLen = this.queue.length
    // 如果当前长度+1<=this.maxLen，那么不需要去除，把queue里最早的那个val去除，在最后面插入
    let index = this.queue.findIndex((item)=>item===val)
    if(currentLen + 1 <= this.maxLen) {
      if(index!==-1){
        this.queue.splice(index,1)
      }
      this.queue.push(val)
    } else { // 否则，如果queue中存在这个值，那么去除；否则，淘汰第一个；在最后面插入
      if(index!==-1) {
        this.queue.splice(index,1)
      }else{
        this.queue.shift()
      }
      this.queue.push(val)
    }
  }

  get(val){
    let index = this.queue.findIndex((item)=>item===val)
    if(index === -1) return -1
    // 找到的这个值，需要更新位置到最后面（最新鲜）
    this.queue.splice(index, 1)
    this.queue.push(val)
    return val
  }
}
```

## 求环状链表
双指针(https://leetcode.cn/problems/linked-list-cycle/)
```js
var hasCycle = function(head) {
    let p1 = head
    let p2 = head

    while(p1!==null && p2!==null) {
        p1 = p1.next
        if(p2.next === null) {
            return false
        }
        p2 = p2.next.next
        if(p1===p2) {
            return true
        }
    }

    return false
};
```

## 二叉树的前序、中序、后序遍历
```js
function preTraverse(root, callback) {
  if(!root) return

  callback(root)
  preTraverse(root.left)
  preTraverse(root.right)
}
```

```js
function midTraverse(root, callback) {
  if(!root) return

  preTraverse(root.left)
  callback(root)
  preTraverse(root.right)
}
```

```js
function postTraverse(root, callback) {
  if(!root) return

  preTraverse(root.left)
  preTraverse(root.right)
  callback(root)
}
```

## 树的层序遍历

```js
function traverse(root, callback) {
  if(!root) return

  let queue = [root]
  while(queue.length) {
    let node = queue.shift()
    traverse(node)

    if(node.children) {
      node.children.forEach((item)=>{
        queue.push(item)
      })
    }
  }
}
```

题目：https://leetcode.cn/problems/binary-tree-level-order-traversal/description/
```js
var levelOrder = function(root) {
    if(!root) return [];

    let queue = [root];
    let res = [];
    while(queue.length) {
        let len = queue.length; // 这一层有几个节点
        let temp = []; // 存储这一层的节点
        while(len) {
           let node = queue.shift();
           len--
           temp.push(node.val);
           // 下一层的节点
           if(node.left) {
            queue.push(node.left)
           }
           if(node.right) {
            queue.push(node.right)
           }
        }
        // 把这一层节点放入结果中
        res.push(temp);
    }

    return res;
};
```

## 获取二叉树的层级
```js
function deepth(root) {
  if(!root) return 0;
  return Math.max(deepth(root.left), deepth(root.right)) + 1;
}
```

## 实现类数组转数组

```js
[...arguments]
Array.from(arguments)
Array.prototype.slice.call(arguments)
Array.prototype.splice.call(arguments, 0)
Array.prototype.concat.apply([], arguments)
Array.apply([], arguments)
```

## 实现DOM转JSON
```js
const dom = document.querySelector('#head_wrapper')

// 只是一个简单实现，当然复杂的还要节点类型以及dom.attributes
function dom2json(dom) {
  let obj = {}
  obj.tag = dom.tagName
  obj.children = []
  dom.childNodes.forEach((child)=> obj.children.push(dom2json(child)))
  return obj
}

console.log(dom2json(dom))
```

## 实现JSON转DOM
```js
const vnode = {
  tag: 'div',
  attrs: {
    id: 'app', class: 'root'
  },
  children: [{
    tag: 'ul',
    children: [
      {tag: 'li', children: ['list 1']},
      {tag: 'li', children: ['list 2']},
      {tag: 'li', children: ['list 2']}
    ]
  }]
}

function json2dom(vnode) {
  if(typeof vnode==='string') {
    return document.createTextNode(String(vnode))
  }

  const node = document.createElement(vnode.tag)
  for(let key in vnode.attrs) {
    node.setAttribute(key, vnode.attrs[key])
  }
  vnode.children.forEach((child)=>{
    node.appendChild(json2dom(child))
  })
  
  return node
}

console.log(json2dom(vnode))
```

## 实现树转数组

```js
[
  {
    id: 1,
    text: '根节点',
    children: [{
      id: 2,
      text: '一级节点1'
    },{
      id: 3,
      text: '一级节点2'
    },{
      id: 4,
      text: '一级节点3'
    }]
  }
]

// 转换结果为：
// [
//   {id: 1, text:'根节点', parentId: 0},
//   {id: 2, text:'一级节点1', parentId: 1},
//   {id: 3, text:'一级节点2', parentId: 1},
//   {id: 4, text:'一级节点3', parentId: 1}
// ]
```

```js
function tree2arr(tree, parentId = 0) {
  let res = []
  if(!tree || !tree.length) return res
  tree.forEach((item)=>{
    item.parentId = parentId
    res.push(item)
    res.push(...tree2arr(item.children, item.id))
    delete item.children
  })
  return res
}
```

## 实现数组转树

```js
[
  {id: 1, text:'根节点', parentId: 0},
  {id: 2, text:'一级节点1', parentId: 1},
  {id: 3, text:'一级节点2', parentId: 1},
  {id: 4, text:'一级节点3', parentId: 1}
]

// 转换结果为
// [{
//   id: 1,
//   text: '根节点',
//   children: [{
//     id: 2,
//     text: '一级节点1'
//   },{
//     id: 3,
//     text: '一级节点2'
//   },{
//     id: 4,
//     text: '一级节点3'
//   }]
// }]
```

```js
function arr2tree(arr) {
  let roots = []

  arr.forEach((item)=>{
    const parent = arr.find((item2)=>item.parentId === item2.id)
    if(!parent) { // 根节点
      roots.push(item)
    } else {
      if(!parent.children) parent.children = []
      parent.children.push(item)
    }
  })

  return roots
}
```

## 实现对象打平

```js
{
  'a': {
    'b': {
      'c': 1,
      'd': 2,
      'e': 3
    }
  }
}

// {'a.b.c': 1, 'a.b.d': 2, 'a.b.e': 3}
```

```js
function flattenObj(obj, prefix = '') {
  let res = {}

  for(let key in obj) {
    let value = obj[key]
    let currentKey = prefix === '' ? key : prefix + '.' + key
    if(typeof value !== 'object' || value === null) {
      res[currentKey] = value
    } else {
      let theObj = flattenObj(value, currentKey)
      Object.assign(res, theObj)
    }
  }

  return res
}
```