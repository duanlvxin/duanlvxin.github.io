---
title: 算法-贪心和动规
date: 2024-08-26 23:52:10
categories:
  - 数据结构与算法
tags:
  - js
  - 算法
cover: https://assets.leetcode.cn/aliyun-lc-upload/uploaded_files/2021/03/73c9f099-abbe-4d94-853f-f8abffd459cd/leetcode.png
---

## 本质
都是根据局部最优解，得出全局最优解

## 贪心

### 饼干问题
https://leetcode.cn/problems/assign-cookies/description/
> 假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。
对每个孩子 i，都有一个胃口值 g[i]，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j，都有一个尺寸 s[j] 。如果 s[j] >= g[i]，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是满足尽可能多的孩子，并输出这个最大数值。

解法：把每块饼干给最小能满足的孩子

```js
var findContentChildren = function (g, s) {
  let result = 0;
  // 胃口从小到大排序，饼干从小到大排序
  g.sort((a,b)=>a-b);
  s.sort((a,b)=>a-b);
  // 看饼干能否满足孩子，可以的话饼干+1,孩子+1
  // 不能的话看下一块饼干，一直往下找
  // 如果找到最后还没有，返回结果；
  let i=0,j = 0; // 当前孩子和饼干位置
  while(i<g.length && j<s.length) {
    if(s[j]>=g[i]) {
        j++
        i++
        result++
    }else {
        j++
    }
  }
  return result;
};
```

### 跳跃游戏
https://leetcode.cn/problems/jump-game/description/
> 给你一个非负整数数组 nums ，你最初位于数组的 第一个下标 。数组中的每个元素代表你在该位置可以跳跃的最大长度。
判断你是否能够到达最后一个下标，如果可以，返回 true ；否则，返回 false 。

解法：每次计算下一步能跳到的最远距离

```js
/**
 * @param {number[]} nums
 * @return {boolean}
 */
var canJump = function (nums) {
  if (nums.length === 0) return false

  let low = 0
  while (true) {
    let high = nums[low] + low // 第一个可以跳到的最远的位置
    if(high >= nums.length - 1) return true

    let next = high // 下一个可以跳到的最远的位置
    let nextIndex = low + 1
    for (let i = low + 1; i <= high; i++) {
      let dis = nums[i] + i
      if(dis > next) {
        next = dis
        nextIndex = i
      }
    }
    if(next === high) return false
    if(next >= nums.length - 1) return true

    low = nextIndex
  }

  return false
};
```

### 跳跃游戏2
https://leetcode.cn/problems/jump-game-ii/description/

>给定一个长度为 n 的 0 索引整数数组 nums。初始位置为 nums[0]。
每个元素 nums[i] 表示从索引 i 向前跳转的最大长度。换句话说，如果你在 nums[i] 处，你可以跳转到任意 nums[i + j] 处

```js
var jump = function (nums) {
  // 如果只有一个值，一步也不用跳
  if (nums.length === 1) return 0

  let low = 0
  let step = 1
  while (true) {
    let high = nums[low] + low // 第一个可以跳到的最远的位置
    if (high >= nums.length - 1) return step

    let next = high // 下一个可以跳到的最远的位置
    let nextIndex = low + 1
    for (let i = low + 1; i <= high; i++) {
      let dis = nums[i] + i
      if (dis > next) {
        next = dis
        nextIndex = i
      }
    }
    if (next >= nums.length - 1) return step + 1

    step++
    low = nextIndex
  }

  return false
};
```

### 买入股票的最佳时机

>给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。
你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。
返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。

解法：记录遇到的最小值，如果当前值大于它，那么有利润并计算利润；否则，更新最小值
```js
/**
 * @param {number[]} prices
 * @return {number}
 */
var maxProfit = function (prices) {
  if (prices.length === 0 || prices.length === 1) {
    return 0;
  }

  let max = 0, preMin = prices[0]
  for (let i = 0; i < prices.length; i++) {
    if(prices[i] > preMin) {
      max = Math.max(max, prices[i] - preMin)
    } else {
      preMin = prices[i]
    }
  }
  return max;
};
```

（其他解法，可忽略）
回溯法（超时）
```js
 // 从里面取出两个，后一个的值减去前一个最大
var maxProfit = function (prices) {
  let max = 0

  let path = []
  function backTrace(startIndex = 0) {
    if(path.length === 2) {
      max = Math.max(max, path[1] - path[0])
      return
    }

    for(let i=startIndex; i<prices.length;i++) {
      path.push(prices[i])
      backTrace(i+1)
      path.pop()
    }
  }

  backTrace()
  return max
};
```

双层遍历（超时）
```js
var maxProfit = function(prices) {
  if(prices.length===0||prices.length===1){
    return 0;
  }

  let res = 0;
  for(let i=0;i<prices.length-1;i++){
    for(let j=i+1;j<prices.length;j++){
      if(prices[j]-prices[i]>res){
        res = prices[j] - prices[i];
      }
    }
  }
  return res;
};
```

### 买入股票的最佳时机2
https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/description/

>给你一个整数数组 prices ，其中 prices[i] 表示某支股票第 i 天的价格。
在每一天，你可以决定是否购买和/或出售股票。你在任何时候 最多 只能持有 一股 股票。你也可以先购买，然后在 同一天 出售。
返回 你能获得的 最大 利润 。

思路：只要一涨，就去卖；
```js
/**
 * @param {number[]} prices
 * @return {number}
 */
var maxProfit = function(prices) {
  let sum = 0

  for(let i=1;i<prices.length;i++) {
    sum += prices[i] > prices[i-1] ? prices[i] - prices[i-1] : 0
  }

  return sum
};
```

## 动态规划

https://blog.csdn.net/qq_47540091/article/details/125505851

### 机器人走路(不同路径)
https://leetcode.cn/problems/unique-paths/description/

> 一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。
机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。
问总共有多少条不同的路径？

```js
var uniquePaths = function (m, n) {
  // dp[i][j] = dp[i][j-1] + dp[i-1][j]
  let dp = Array.from(Array(m), () => Array(n).fill(1))

  for (let i = 1; i < m; i++) {
    for (let j = 1; j < n; j++) {
      dp[i][j] = dp[i][j - 1] + dp[i - 1][j]
    }
  }

  return dp[m - 1][n - 1]
};
```


### 机器人走路2（不同路径2）

https://leetcode.cn/problems/unique-paths-ii/description/

> 一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。
机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish”）。
现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？
网格中的障碍物和空位置分别用 1 和 0 来表示。

解法：
`dp[i][j] = dp[i][j] = obstacleGrid[i][j] === 1 ? 0 : dp[i-1][j] + dp[i][j-1]`

```js
/**
 * @param {number[][]} obstacleGrid
 * @return {number}
 */
var uniquePathsWithObstacles = function (obstacleGrid) {

  let m = obstacleGrid.length, n = obstacleGrid[0].length

  let dp = Array.from(Array(m), () => Array(n).fill(0))
  dp[0][0] = 1 - obstacleGrid[0][0]
  // 初始化第一行和第一列
  for (let i = 1; i < m; i++) {
    if (obstacleGrid[i][0] === 0 && dp[i - 1][0]) {
      dp[i][0] = 1
    }
  }
  for (let j = 1; j < n; j++) {
    if (obstacleGrid[0][j] === 0 && dp[0][j - 1]) {
      dp[0][j] = 1
    }
  }

  for (let i = 1; i < m; i++) {
    for (let j = 1; j < n; j++) {
      dp[i][j] = obstacleGrid[i][j] === 1 ? 0 : dp[i-1][j] + dp[i][j-1]
    }
  }

  return dp[m - 1][n - 1]
};
```

另一种考虑方式：（需要额外判断终点是否有障碍物）
`dp[i][j] = (1 - obstacleGrid[i - 1][j]) * dp[i - 1][j] + (1 - obstacleGrid[i][j - 1]) * dp[i][j - 1]`
```js
var uniquePathsWithObstacles = function (obstacleGrid) {
  let m = obstacleGrid.length, n = obstacleGrid[0].length
  // 如果起点终点本身有障碍物，那么路径是0
  if (obstacleGrid[0][0] === 1 || obstacleGrid[m - 1][n - 1] === 1) return 0

  let dp = Array.from(Array(m), () => Array(n).fill(0))
  dp[0][0] = 1
  // 初始化第一行和第一列
  for (let i = 1; i < m; i++) {
    if (obstacleGrid[i][0] === 0 && dp[i - 1][0]) {
      dp[i][0] = 1
    }
  }
  for (let j = 1; j < n; j++) {
    if (obstacleGrid[0][j] === 0 && dp[0][j - 1]) {
      dp[0][j] = 1
    }
  }

  for (let i = 1; i < m; i++) {
    for (let j = 1; j < n; j++) {
      dp[i][j] = (1 - obstacleGrid[i - 1][j]) * dp[i - 1][j] + (1 - obstacleGrid[i][j - 1]) * dp[i][j - 1]
    }
  }

  return dp[m - 1][n - 1]
};
```

### 最小路径和
https://leetcode.cn/problems/0i0mDW/description/

>给定一个包含非负整数的 m x n 网格 grid ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。
说明：一个机器人每次只能向下或者向右移动一步。

```js
// dp[i][j] = Math.min(dp[i-1][j], dp[i][j-1]) + grid[i][j]
var minPathSum = function (grid) {
  let m = grid.length, n = grid[0].length

  let dp = Array.from(Array(m), () => Array(n).fill(0))

  dp[0][0] = grid[0][0]

  // 初始化第一行和第一列
  for (let i = 1; i < m; i++) {
    dp[i][0] = dp[i - 1][0] + grid[i][0]
  }
  for (let j = 1; j < n; j++) {
    dp[0][j] = dp[0][j - 1] + grid[0][j]
  }

  for (let i = 1; i < m; i++) {
    for (let j = 1; j < n; j++) {
      dp[i][j] = Math.min(dp[i-1][j], dp[i][j-1]) + grid[i][j]
    }
  }

  return dp[m - 1][n - 1]
};
```

### 最大子数组和(最大和的连续子数组)

https://leetcode.cn/problems/maximum-subarray/

>给你一个整数数组 nums ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。
子数组是数组中的一个连续部分。

动态规划解法：
```js
/**
 * @param {number[]} nums
 * @return {number}
 */
// 对于到末尾到第i个下标的数组，在第i个位置上，可以要前面的，也可以不要前面的：Math.max(dp[i-1] + nums[i], nums[i])
var maxSubArray = function (nums) {
  if (nums.length === 0) return 0

  let dp = [nums[0]], max = nums[0]
  for (let i = 1; i < nums.length; i++) {
    dp[i] = Math.max(dp[i-1] + nums[i], nums[i])
    max = Math.max(dp[i], max)
  }

  return max
};
```

贪心解法：
只要你有负数（前面的子数组），那么一定会拉低我的值，我就不要你
```js
var maxSubArray = function (nums) {
  if (nums.length === 0) return 0

  let sum = 0
  for(let i=0;i<nums.length;i++) {
    if(sum > 0) {
      sum = sum + nums[i]
    } else {
      sum = nums[i]
    }
    result = Math.max(result, sum)
  }

  return result
};
```

### 最长上升子序列
https://leetcode.cn/problems/longest-increasing-subsequence/description/

> 给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。
子序列 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。

```js
// dp[i]表示子数组最后一个值取到i的子数组，他的最长严格递增子序列的长度
// 找到前面比当前值小的那个数dp[k] dp值最大的+1
var lengthOfLIS = function (nums) {
  if (nums.length === 0) return 0

  let dp = [1], max = 1
  for (let i = 1; i < nums.length; i++) {
    let tempMax = 1
    let k = i - 1
    while(k>=0) {
      if(nums[k] < nums[i]) {
          tempMax = Math.max(tempMax, dp[k] + 1)
      }
      k--
    }
    dp[i] = tempMax
    max = Math.max(max, dp[i])
  }

  return max
};
```

### 零钱兑换
https://leetcode.cn/problems/coin-change/description/

>给你一个整数数组 coins ，表示不同面额的硬币；以及一个整数 amount ，表示总金额。
计算并返回可以凑成总金额所需的 最少的硬币个数 。如果没有任何一种硬币组合能组成总金额，返回 -1 。
你可以认为每种硬币的数量是无限的。
示例 1：
输入：coins = [1, 2, 5], amount = 11
输出：3 
解释：11 = 5 + 5 + 1

```js
var coinChange = function (coins, amount) {
  // dp[amout]表示凑amount块钱，需要的最少硬币数
  let dp = new Array(amount + 1)
  dp[0] = 0
  // 这个硬币数量一定小于amount+1(因为硬币最小值是1，最多需要amount个1块钱硬币)
  for (let i = 1; i < amount + 1; i++) {
    dp[i] = amount + 1
  }
  // dp[11] => Math.min(12， dp[10] + 1, dp[9] + 1, dp[5] + 1) // 分别是最大值以及取1，2，5得到的最优解
  // dp[i] = Math.min(dp[i], dp[i-coins[j]] + 1) 如果i>=coins[j]
  for (let i = 1; i < amount + 1; i++) {
    for (let j = 0; j < coins.length; j++) {
      if(i >= coins[j]) {
        dp[i] = Math.min(dp[i], dp[i - coins[j]] + 1)
      }
    }
  }
  return dp[amount] === amount + 1 ? -1 : dp[amount]
}
```

### 填满背包的最大价格
>背包问题 给定两个长度都为N的数组weights和values，weights[i]和values[i]分别代表 i号物品的重量和价值 给定一个正数bag，表示一个载重bag的袋子，装的物品不能超过这个重量 返回能装下的最大价值

```js
function maxValue(weights, values, bag) {
  // dp[i]表示载重为i的袋子能装下的最大价值
  let dp = new Array(bag + 1).fill(0)
  let max = 0

  let len = weights.length
  for(let i=0;i<bag+1;i++) { // 遍历所有载重，得到所有dp
    for(let j=0;j<len;j++) { // 遍历所有物品
      if(i>=weights[j]) { // 如果物品重量小于载重，那么可以放
        dp[i] = Math.max(dp[i], dp[i-weights[j]] + values[j])
        max = Math.max(max, dp[i])
      }
    }
  }

  return max
}
```
