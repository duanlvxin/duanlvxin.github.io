---
title: 前端面试题-基础篇
date: 2024-08-11 13:51:09
tags:
  - 面试
categories:
  - 面试
cover: /img/mianshi.jpg
mathjax: true
---

## HTML

### 前端需要注意哪些SEO

<details>
<summary>展开查看</summary>
<pre>
  <code>
1、meta标签中的title, description, keywords
2、语义化标签
3、重要的html放在最前面
4、重要的html不用Js动态生成
5、少用Iframe
6、图片增加alt
7、提高网站速度
8.用div+css代替table
  </code>
</pre>
</details>

### img的title和alt有什么区别

<details>
<summary>展开查看</summary>
<pre>
  <code>
title是鼠标悬浮展示的问题
alt是读屏器显示文字或者图片无法获取展示的问题
</code>
</pre>
</details>

### 语义化的理解

<details>
<summary>展开查看</summary>
<pre>
  <code>
定义：用正确的标签做正确的事情。
语义化的标签有head,aside, footer, article, main等。
作用：
- seo方面：语义化标签有利于搜索引擎解析，有利于seo
- css方面：在没有css样式的情况下也能以一种文档格式显示，并且是容易阅读的
- 代码方面：代码可读性、有利于代码维护
</code>
</pre>
</details>

### html5有哪些新特性，移除了哪些元素
<details>
<summary>展开查看</summary>
<pre>
  <code>
新增：
1、canvas
2、video，audio
3、增加语义化标签(header,footer等)
4、表单控件(form, calendar, date等)
4、sessionStorage, localStorage
5、web worker, Geolocation
6、离线缓存

移除：
1、s,font,big等标签；
2、frame, frameset,noframes等标签
  </code>
</pre>
</details>


### html5的离线缓存怎么用，工作原理？
<details>
<summary>展开查看</summary>
<pre>
  <code>
- 作用
  在用户没有网络连接时使用本地离线缓存的资源正常展示页面，有网络连接时更新资源。
- 原理
  html5的离线缓存是通过一个.appstore文件实现的，其中定义了需要缓存的资源。
  在离线状态下使用缓存资源；在在线情况下，更新缓存。
- 如何使用
  1.在html标签中定义mainfest="xxx.appstore"
  2.xxx.appstore中定义需要缓存的资源
  3.通过window.applicationcache操作缓存的资源(已经被废弃了)
  </code>
</pre>
</details>

### 浏览器是怎么对HTML5的离线存储资源进行管理和加载的呢？
<details>
<summary>展开查看</summary>
<pre>
  <code>
1.在线时：
  （1）看html文件是否有mainfest属性，如果有加载mainfest文件；
  （2）如果是第一次访问app,就会下载并缓存mainfest中定义的文件；
  （3）如果非第一次，浏览器会使用离线的资源加载页面；然后比对新的mainfest和旧的mainfest文件，如果文件内容没有发生变化，就不做任何操作；如果文件内容改变了，浏览器会重新下载mainfest文件中列出的资源并进行离线缓存(再下一次才会是更新后的页面）。
2.离线时：直接加载离线缓存资源
  </code>
</pre>
</details>

### 说说cookie,sesssionStorage,localStorage,innerDB的区别
<details>
<summary>展开查看</summary>
<pre>
  <code>
存储大小，清除时间，请求携带
  </code>
</pre>
</details>

### iframe优缺点
<details>
<summary>展开查看</summary>
<pre>
  <code>
优点：
1、使用方便简单，不用重复开发
缺点：
1、seo方面
2、阻塞主页面的onload事件
3、和主页面共享连接池，而浏览器对相同域的连接数有限制，会影响页面的并行加载
  </code>
</pre>
</details>

### web标准和w3c标准

<details>
<summary>展开查看</summary>
<pre>
  <code>
1、标签小写
2、标签闭合
3、不乱嵌套标签
4、语义化，结构和样式分离
  </code>
</pre>
</details>

### xhtml和html有什么区别
<details>
<summary>展开查看</summary>
<pre>
  <code>
  xhtml比html语法更严格，如标签必须闭合等
  xhtml基于xml,html4.x基于SGML,html5.0是自身的规范（xml是SGML的子级）
  </code>
</pre>
</details>

### Doctype作用？严格模式与混杂模式如何区分？它们有什么意义？
<details>
<summary>展开查看</summary>
<pre>
  <code>
Doctype告知浏览器需要怎样解析文档
严格模式和混杂模式通过DTD文件区分，所以HTML5中没有严格模式和混杂模式之分
严格模式会用严格w3c标准去解析，混杂模式语法更宽松，兼容老旧的浏览器。
  </code>
</pre>
</details>

### 为什么html5只需要\<!Doctype html\>了

<details>
<summary>展开查看</summary>
<pre>
  <code>
因为html5不是基于SGML了，不需要dtd文件
  </code>
</pre>
</details>

### 行内元素和块状元素有哪些？空元素有哪些？行内元素和块状元素的区别
<details>
<summary>展开查看</summary>
<pre>
  <code>
行内元素: a,b,span,strong,em
块状元素：div,h1-h6,p,table,ul,li
空元素（不能有子节点的）：br,hr,input,link,meta,img
行内元素不能设置宽高，不独占一行；
块状元素能设置宽高，独占一行
  </code>
</pre>
</details>

### HTML全局属性有哪些
<details>
<summary>展开查看</summary>
<pre>
  <code>
1.id
2.class
3.data-*
4.style
5.title
6.draggable
7.lang
  </code>
</pre>
</details>

### Canvas和svg的区别
<details>
<summary>展开查看</summary>
<pre>
  <code>
1.canvas绘制的是位图，svg是矢量图
2.canvas放大会失真, svg不会
3.canvas适合图像密集型，如游戏等
4.svg内部都是dom元素，可以直接操控
  </code>
</pre>
</details>

### viewport,逻辑像素和物理像素
<details>
<summary>展开查看</summary>
<pre>
  <code>
1.width // 设置viewport宽度，正整数，或字符串device-width
2.height // 设置viewport高度，正整数，或字符串deivce-height
3.initial-scale // 初始缩放比例
4.mininum-scale // 允许用户最小缩放比例
5.maxinum-scale // 允许用户最大缩放比例
6.user-scalable // 是否允许手动缩放
  </code>
</pre>
</details>

### div+css的布局较table布局有什么优点
<details>
<summary>展开查看</summary>
<pre>
  <code>
1.性能优势：
  （1）代码精简
  （2）页面渲染速度（div+css 表现和结构分离）
2.seo优势
  （1）提高搜索引擎抓取效率（和table相比，减少了嵌套和冗余，更有利于搜索引擎解析）
  （2）提高页面质量得分
  （3）减少相似页面
  （4）更好的可访问性和用户体验(div+css 支持无障碍阅读)
  </code>
</pre>
</details>

### 渲染优化
<details>
<summary>展开查看</summary>
<pre>
  <code>
1.禁止使用iframe
2.禁止使用gif图片实现loading
3.使用css3动画代替js动画
4.小图片尽量用base64
5.页面中不要出现空的href和src
6.网页gzip,cdn托管,data缓存，图片服务器
7.当需要很多样式时用className,不直接操控style
8.少用全局变量，缓存dom节点查找结果
9.将样式表放在顶部，将js放在底部
  </code>
</pre>
</details>

### src和href的区别

<details>
<summary>展开查看</summary>
<pre>
  <code>
src是定义要下载资源的地址,href是建立与资源的联系
如img上的src,a标签上的href
  </code>
</pre>
</details>


### strong和em的区别
<details>
<summary>展开查看</summary>
<pre>
  <code>
strong是粗体,em是斜体
strong表示重要性, em表示强调
  </code>
</pre>
</details>

### strong和b的区别
<details>
<summary>展开查看</summary>
<pre>
  <code>
b标签和strong标签在网页中的显示效果是一样的，但实际目的不同。
b标签是为了加粗的显示效果而使用，是样式标签；而strong标签是为了强调文本的重要性，是语义化标签。
  </code>
</pre>
</details>

## CSS

## JS

### 闭包
<details>
<summary>展开查看</summary>
<ul>
<li>能读取其他函数内部变量的函数</li>
</ul>
</details>

### 作用域链
<details>
<summary>展开查看</summary>
<ul>
<li>控制变量和函数的可访问范围</li>
<li>只能向上访问，不能向下访问</li>
<li>全局作用域，函数作用域，块级作用域</li>
</ul>
</details>

### js的原型和原型链

<details>
<summary>展开查看</summary>
<pre>
  <code>
1.obj.toString()和Object.prototype.toString.call(obj)结果为何不同？
2.obj.__proto__和Object.getPrototypeOf(obj)一样吗？
3.如何优先使用顶层原型上的变量/函数？（Object.defineProperty,get)
  </code>
</pre>
</details>

### 事件代理

### js实现继承

### 对this对象的理解

### 事件模型

### new操作符
<details>
<summary>展开查看</summary>
<pre>
  <code>
1. 定义一个对象
2. 修改对象的原型，指向构造函数原型
3. 在对象上调用构造函数,得到result
4. result是对象，则返回这个对象；否则返回定义的对象
  </code>
</pre>
</details>

### ajax原理

<details>
<summary>展开查看</summary>
<pre>
  <code>
const xhr = new XMLHttpRequest()
xhr.open('get', url, true)
xhr.send(data)
xhr.onreadyStateChange = function() {
  if(xhr.readyState === 4) {
    if(xhr.status === 200) {
      success(xhr.responseText);
    } else {
      fail(xhr.status);
    }
  }
}
  </code>
</pre>
</details>

### 如何解决跨域问题
<details>
<summary>展开查看</summary>
<pre>
  <code>
jsonp, 服务端Access-cross-allow-origin, 服务代理，document.domain+iframe(只能实现同一个主域，不同子域之间的操作)
  </code>
</pre>
</details>

### 模块化开发该怎么做
<details>
<summary>展开查看</summary>
<pre>
  <code>
以前：立即执行函数，不暴露私有变量
现在：cmd,amd,cjs,esmodule
  </code>
</pre>
</details>

### 异步加载js的方法
<details>
<summary>展开查看</summary>
<pre>
  <code>
script标签中defer/async
动态script标签
  </code>
</pre>
</details>

### 哪些操作会导致内存泄漏
<details>
<summary>展开查看</summary>
内存泄漏是指任何对象或变量在不需要它后仍然存在，导致内存没有回收
<ul>
<li>未正确使用的闭包</li>
<li>未回收的全局变量</li>
<li>定时器</li>
<li>未回收的dom引用（垃圾回收机制无法识别）</li>

todo 未正确使用的闭包导致内存泄漏举例？
</ul>
</details>

### xml和json的区别
<details>
<summary>展开查看</summary>
<ul>
<li>体积上：json比xml更轻量</li>
<li>方便性：json比xml更简单方便，更容易解析</li>
<li>数据上: xml数据描述性比json更强</li>
</ul>
</details>

### 设计模式
用过哪些设计模式，设计模式的6大原则？

### 为什么要有同源限制
<details>
<summary>展开查看</summary>
<pre>
  <code>
定义:ip,端口，协议都相同。
作用：web安全
比如一个网站，嵌入银行网站登录页面，如果没有同源显示，可以点登录的时候发送请求到攻击者的网站，就可以获取到登录名和密码
  </code>
</pre>
</details>

### offsetWidth/offsetHeight,
<details>
<summary>展开查看</summary>
<pre>
  <code>
offsetWidth/offsetHeight包括content,padding,border
clientWidth/clientHeight包括content,padding
scrollWidth/scrollHeight包括content,padding+溢出内容的尺寸
  </code>
</pre>
</details>

todo 实现getBoundingClientRect() ?

### js有哪些方法定义对象
<details>
<summary>展开查看</summary>
<ul>
<li>对象字面量</li>
<li>Object.create</li>
<li>new Object()</li>
</ul>
</details>

### 常见兼容性问题
<details>
<summary>展开查看</summary>
<ul>
<li>浏览器默认的margin和padding不同</li>
<li>addEventListener,attachEvent</li>
<li>ie下,event对象只有x,y;没有pageX,pageY</li>
</ul>
</details>

### 对promise的了解，手写一个promise

### js的基本数据类型
<details>
<summary>展开查看</summary>
<pre>
  <code>
string,number,boolean,null,undefined,object | symbol bigint
symbol:独一无二，不可变=》全局变量冲突，内部变量覆盖
bigint:可以表示超过2^53-1的数字
  </code>
</pre>
</details>

### JS ES的内置对象由哪些
<details>
<summary>展开查看</summary>
<pre>
  <code>
1.值属性类: Infinity,NaN,undefined,null
2.函数属性: parseInt,parseFloat
3.对象: Object,Function,Boolean,Symbol,Error
4.数字: Number,Math,Date
5.字符串: String,RegExp
6.集合: Set,Map,WeakMap
7.抽象控制: promise
8.映射: proxy
  </code>
</pre>
</details>

### js有几种类型的值
<details>
<summary>展开查看</summary>
<pre>
  <code>
原始数据类型：string,number,boolean,null,undefined,symbol
引用数据类型：对象，数组，函数

区别：
1.存储位置不同
  原始数据类型放在栈中=》栈区由编译器自动分配释放=》临时变量方式
  引用数据类型=》堆内存由开发者进行分配？（大部分其他语言中）=》直到应用结束
2.效果不同(存储位置不同，导致效果不同)
  原始数据类型赋值后，不存在引用关系
  属性引用关系

原始数据类型放在堆中，空间小，大小固定，操作频繁
引用类型数据大，大小不固定，赋值给的是地址
  </code>
</pre>
</details>

### 类型转换

#### isNaN和Number.isNaN的区别
<details>
<summary>展开查看</summary>
<pre>
  <code>
isNaN会尝试进行数据类型转换，如果不能转为number,那就是NaN
Number.isNaN会先判断是否是数字，如果不是，返回true，再判断能不能转为number

所以isNaN(undefined) // true
Number.isNaN(undefined) // false
但要注意isNaN(null)和Number.isNaN（null)是true,因为Number(undefined)是0
  </code>
</pre>
</details>


#### 其他类型转换的场景
<details>
<summary>展开查看</summary>
<pre>
  <code>
1.转成字符串
2.转成数字
3.转成布尔值
  undefined,null,"", +0,-0, NaN, false => false
  </code>
</pre>
</details>

#### 原始类型的值是如何具有属性操作的？
<details>
<summary>展开查看</summary>
<pre>
  <code>
1.是因为js的包装类型
原始数据类型，在调用属性的时候，js会隐式地将其转为对象
如 let a = '123'; console.log(a.length); //3
Object(a) // String {'123'}

2.如何去包装
a.valueOf()
  </code>
</pre>
</details>

### 变量提升和变量提升的意义
<details>
<summary>展开查看</summary>
<pre>
  <code>
无论在任何位置声明的函数、变量都会被提升到当前作用域顶部
函数作用域优先级高于变量。
变量声明前访问是undefined,函数就是函数

意义：
1.性能（解析引用提升了性能，不需要执行到重新解析）
2.更加灵活
  </code>
</pre>
</details>

### eval的作用

### null和undefined的区别

### 同步和异步的区别

### 渐进增强和优雅降级

### 严格模式的限制
<details>
<summary>展开查看</summary>
<ul>
<li>变量必须先声明后使用</li>
<li>函数参数不能有同名变量</li>
<li>不能用width</li>
<li>this不能指向全局变量</li>
</ul>
</details>

### attribute和property的区别
<details>
<summary>展开查看</summary>
<ul>
<li>attribute是dom相关的，property是js相关的</li>
<li>attribute有property没有的属性，property也有attribute没有的属性</li>
<li>attribute有id,class,style等，property有id,nextSibling等</li>
</ul>
</details>

### ES6

### 面向对象编程和面向过程编程

## HTTP

### http的几种请求方法和用途

- get 获取
- post 更新
- put 上传
- delete 删除
- head 只获取头部
- options 预检请求（服务端支持哪些方法，cors）
- connect 建立隧道
- trace 追踪请求路径

### http状态码和含义
- 1xx
  - 100 continue
  - 101 switching protocal
- 2xx
  - 200 请求成功
  - 201 range请求成功
  - 204 请求成功，但没有内容
- 3xx
  - 301 永久重定向
  - 302 临时重定向, 请求方法不变为get(但是大部分浏览器会变)
  - 303 临时重定向，请求方法都变为get
  - 304 not modified
  - 307 临时重定向, 不允许请求方法变为get
- 4xx
  - 400 客户端请求体错误
  - 401 未进行认证
  - 403 认证不通过（forbidden）
  - 405 客户端请求方法不允许
- 5xx
  - 500 服务内部错误
  - 503 服务不可达，服务过载或维护

### 永久重定向和临时重定向的区别

### http请求报文

### http响应报文

### http1.0 vs http1.1 vs http2.0

### https

### TCP和UDP

### OSI七层模型

### 常见web安全和防护原理

## 浏览器

### 从浏览器地址栏输入url到显示页面的步骤(重要)

### 如何进行网站性能优化(重要)

1.content方面
   (1) 减少https请求：合并文件
  （2）减少DNS查询
  （3）减少DOM数量
  （4）简单的动画用css3动画代替js动画
2.server方面
  （1）etag缓存
  （2）cdn
  （3）gzip压缩
3.js方面
  （1）压缩js文件
   (2) 将脚本放到页面底部
  （3）删除不需要的脚本
  （4）减少DOM访问
  （5）将js和css从外部引入？
4.css方面
   (1) 合并css文件
  （2）将样式表放到页面顶部
  （3）少使用css表达式
  （4）使用Link不使用@import
5.图片方面
  （1）精灵图
  （2）图片压缩
  （3）inline image(base64图片)
  （4）不要在html中拉伸图片
6.cookie方面
  （1）减少cookie大小

### 浏览器内核
渲染引擎和js引擎
渲染引擎：chrome是blink，safari是webkit
js引擎: 主要是v8引擎

### web开发中常用的会话跟踪方法
<details>
<summary>展开查看</summary>
<ul>
<li>cookie,sessionStorage和localStorage</li>
<li>session</li>
<li>ip地址</li>
</ul>
</details>

### 对web标准、可用性、可访问性的理解

## 综合

### 为什么利用多个域名来存储网站资源会更有效

### 一次js请求一般情况下有哪些地方会有缓存处理？

### 一个页面上有大量的图片，加载很慢，有哪些方法优化这些图片的加载，给用户更好的体验
