---
title: 算法-二分与回溯
date: 2024-08-19 22:53:44
categories:
  - 数据结构与算法
tags:
  - js
  - 算法
cover: https://assets.leetcode.cn/aliyun-lc-upload/uploaded_files/2021/03/73c9f099-abbe-4d94-853f-f8abffd459cd/leetcode.png
---

**二分和回溯在代码书写上是有明确的公式的。**

## 二分

前提：有序数组
思想：判断中间位置的值大小，对半分去找

```js
function search(arr, target) {
  let low = 0, high = arr.length - 1
  while(low <= high) {
    let mid = low + ((high - low) >> 1)
    if(arr[mid] === target) {
      return mid;
    }else if(arr[mid]<target){
      low = mid + 1;
    } else {
      high = mid -1;
    }
  }
  return -1;
}
```

【相关题库】：https://leetcode.cn/tag/binary-search/problemset/
【经典题目】：
求平方根 - https://leetcode.cn/problems/sqrtx/description/
寻找旋转排序数组中的最小值 - https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array/description/

## 回溯

```js
function combine(n, k) {
  let result = [], path = []

  function backTrace() {
    // 停止条件
    if(condition) {
      result.push([...path]);
      return;
    }

    // 尝试一个，然后去掉这个尝试，进行下一轮
    for(condition) {
      path.push(i);
      backTrace();
      path.pop();
    }
  }

  backTrace();
  return result;
}
```

【相关题库】：https://leetcode.cn/tag/backtracking/problemset/
【经典题目】：
1. 组合1: 给定两个整数 n 和 k, 返回范围 [1,n] 中所有可能的 k 个数的组合
https://leetcode.cn/problems/combinations/description/
```js
/**
 * @param {number} n
 * @param {number} k
 * @return {number[][]}
 */
var combine = function(n, k) {
  let result = [], path = []
  
  function backTrace(startIndex) {
    if(path.length===k) {
      result.push([...path]);
      return;
    }

    for(let i=startIndex;i<=n;i++){
      path.push(i);
      backTrace(i+1);
      path.pop();
    }
  }

  backTrace(1);
  return result;
};
```
2. 组合总数：找出candidates中可以使数字和为目标数 target 的所有 不同组合（需要不重复）
https://leetcode.cn/problems/combination-sum/description/

关键在于从某个值开始找到了组合之后，之后的值不能再使用这个值了（startIndex）
```js
/**
 * @param {number[]} candidates
 * @param {number} target
 * @return {number[][]}
 */
var combinationSum = function (candidates, target) {
  let result = [], path = []

  function backTrace(startIndex = 0, sum = 0) {
    // 和如果满足，放入结果，返回
    if (sum === target) {
      result.push([...path])
      return true
    }

    // 遍历可选数组，选择一个值
    for (let i = startIndex; i < candidates.length; i++) {
      if(sum + candidates[i] > target) return
      path.push(candidates[i])
      backTrace(i, sum + candidates[i])
      path.pop()
    }
  }

  // 从小到大排序
  candidates.sort((a, b) => a - b)
  backTrace(0, 0)

  return result
};
```

3. 组合总数2: 找出candidates中可以使数字和为目标数 target 的所有 不同组合， candidates中的值不能重复取
https://leetcode.cn/problems/combination-sum-ii/description/
```js
/**
 * @param {number[]} candidates
 * @param {number} target
 * @return {number[][]}
 */
var combinationSum2 = function (candidates, target) {
  let result = [], path = []

  function backTrace(startIndex, sum = 0) {
    // 和如果满足，放入结果，返回
    if (sum === target) {
      result.push([...path])
      return
    }

    // 遍历可选数组，选择一个值
    for (let i = startIndex; i < candidates.length; i++) {
      if(sum + candidates[i] > target) return
      if(i===startIndex || candidates[i] !== candidates[i-1]) {
        path.push(candidates[i])
        backTrace(i + 1, sum + candidates[i])
        path.pop()
      }
    }
  }

  // 从小到大排序
  candidates.sort((a, b) => a - b)
  backTrace(0, 0)

  return result
};
```

4. 全排列: 数组nums, 返回其所有可能的全排列
https://leetcode.cn/problems/permutations/description/
```js
/**
 * @param {number[]} nums
 * @return {number[][]}
 */
var permute = function(nums) {
  let result = [], path = []

  function backTrace(tempNums) {
    if(path.length === nums.length) {
      result.push([...path]);
      return;
    }

    for(let i=0;i<tempNums.length;i++) {
      path.push(tempNums[i]);
      let currentNums = [...tempNums];
      currentNums.splice(i,1)
      backTrace(currentNums);
      path.pop();
    }
  }

  backTrace(nums)
  return result;
};
```
5. 全排列2: 数组nums, 返回其所有可能的全排列，不重复
https://leetcode.cn/problems/permutations-ii/description/

```js
// [1,1,2] => [[1,1,2],[1,2,1],[2,1,1]]
var permuteUnique = function (nums) {
  let result = [], path = []
  let visited = []
  function backTrace() {
    if (path.length === nums.length) {
      result.push([...path]);
      return;
    }

    for (let i = 0; i < nums.length; i++) {
      // 剪枝
      if(visited[i] || (i>0 && nums[i] === nums[i-1] && !visited[i-1])) {
        continue
      }

      path.push(nums[i])
      visited[i] = true
      backTrace()
      visited[i] = false
      path.pop()
    }
  }

  // 排序，为了解决重复元素的问题
  nums.sort((a,b) => a-b)
  backTrace()
  return result;
};
```

6. N皇后问题
https://leetcode.cn/problems/n-queens/submissions/104834571/

```js
/**
 * @param {number} n
 * @return {string[][]}
 */
var solveNQueens = function (n) {
  function initChess(n) {
    let chess = [];
    for (let i = 0; i < n; i++) {
      chess[i] = []
      for (let j = 0; j < n; j++) {
        chess[i][j] = '.';
      }
    }
    return chess;
  }

  function isValid(x, y, chess) {
    let n = chess.length;
    // 这一列上存在别的皇后
    for (let i = 0; i < x; i++) {
      if (chess[i][y] == 'Q') {
        return false;
      }
    }

    // 左上角存在别的皇后
    for (let i = x - 1, j = y - 1; i >= 0 && j >= 0; i--, j--) {
      if (chess[i][j] == 'Q') {
        return false;
      }
    }

    // 右上角存在别的皇后
    for (let i = x - 1, j = y + 1; i >= 0 && j < n; i--, j++) {
      if (chess[i][j] == 'Q') {
        return false;
      }
    }

    return true;
  }

  function solve(chess, row) {
    if (row == chess.length) {
      let ans = [];
      for (let i = 0, len = chess.length; i < len; i++) {
        ans[i] = chess[i].join("");
      }
      res.push(ans);
      return;
    }

    for (let i = 0, len = chess.length; i < len; i++) {
      if (isValid(row, i, chess)) {
        chess[row][i] = 'Q';
        solve(chess, row + 1);
        chess[row][i] = '.';
      }
    }
  }
  let chess = initChess(n);
  let res = [];
  solve(chess, 0);
  return res;
};
```
