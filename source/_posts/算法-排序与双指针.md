---
title: 算法-排序与双指针
date: 2024-08-23 21:52:10
categories:
  - 数据结构与算法
tags:
  - js
  - 算法
cover: https://assets.leetcode.cn/aliyun-lc-upload/uploaded_files/2021/03/73c9f099-abbe-4d94-853f-f8abffd459cd/leetcode.png
---

## 排序

O(n^2)的排序算法：冒泡，选择，插入
O(nlogn)的排序算法：快排，归并
O(n)的排序算法：桶排序，计数排序，基数排序

### 冒泡排序
1.第一轮，相邻的两个两两比较，把最小的冒泡到第1个
2.第二轮，相邻的两个两两比较，把第二小的冒泡到第2个
3.重复len-1轮

```js
function bubbleSort(arr) {
  for (let i = 0; i < arr.length - 1; i++) {
    for (let j = arr.length - 1; j > i; j--) {
      if (arr[j - 1] > arr[j]) {
        [arr[j - 1], arr[j]] = [arr[j], arr[j - 1]]
      }
    }
  }
}
```

或者反过来想，把最大的冒泡到最后面
```js
function bubbleSort(arr) {
  for (let i = arr.length - 1; i > 1; i--) {
    for (let j = 0; j < i; j++) {
      if (arr[j] > arr[j + 1]) {
        [arr[j + 1], arr[j]] = [arr[j], arr[j + 1]]
      }
    }
  }
}
```

### 选择排序
1.第一轮，选取最小的放到第1个
2.第二轮，选取第二小的放到第2个
3.重复len-1轮

```js
function selectSort(arr) {
  for(let i=0;i<arr.length-1;i++) {
    let minIndex = i;
    for(let j=i+1;j<arr.length;j++) {
      if(arr[j]<arr[minIndex]) {
        minIndex = j
      }
    }
    if(minIndex!==i) {
      [arr[i], arr[minIndex]] = [arr[minIndex], arr[i]]
    }
  }
}
```

### 插入排序
1. 从第2个开始，往前找，如果一直是大于这个数的，把这些数往后移，最后插入这个数
2. 从第3个，重复这个过程（len-1轮）

```js
function insertSort(arr) {
  for (let i = 1; i < arr.length; i++) {
    let currentVal = arr[i]
    let j = i - 1 // j是需要插入的位置的前一个位置
    while (j >= 0) {
      if (arr[j] > currentVal) {
        arr[j + 1] = arr[j]
        j--
      } else {
        break;
      }
    }
    arr[j + 1] = currentVal
  }
}
```

### 快速排序
1.从数组中选取一个作为pivot,把小于等于pivot的移到左边，把大于pivot的移到右边
2.继续快速排序左边的和右边的

```js
// 非原地排序版本
function quickSort(arr) {

  if(arr.length <= 1) return arr;

  const pivotIndex = Math.floor(Math.random(0, arr.length));
  const pivot = arr[pivotIndex];

  let left = arr.filter((item,index)=>item<=pivot && index!==pivotIndex);
  let right = arr.filter((item)=>item>pivot);

  return [...quickSort(left), pivot, ...quickSort(right)]
}
```

```js
// 原地排序版本
function quickSort(arr) {

  function q(arr, low, high) {

    if(high-low<=0) return;

    const pivotIndex = low + Math.floor(Math.random(0, high+1));
    const pivot = arr[pivotIndex];

    let i=low,j=high
    while(true) {
      while(arr[i]<=pivot) {
        i++
      }

      while(arr[j]>pivot) {
        j--
      }

      if(i>=j) break;

      [arr[i], arr[j]] = [arr[j], arr[i]]
      i++
      j--
    }
    // 把pivot放到合适的位置上
    [arr[pivotIndex] , arr[j]] = [arr[j], arr[pivotIndex]]

    q(arr, low, j - 1)
    q(arr, j + 1, high)
  }

  q(arr, 0 ,arr.length - 1)
}
```

### 归并排序
1.排序左边的，排序右边的
2.合并两个有序数组

```js
function mergeSort(arr) {
  if (arr.length <= 1) return arr;

  let mid = (arr.length >> 1) - 1; // 这里不减一的话数组长度为2时会无限递归

  const left = mergeSort(arr.slice(0, mid + 1))
  const right = mergeSort(arr.slice(mid + 1))

  function merge(arr1, arr2) {
    let res = []
    let i = 0, j = 0

    while (i < arr1.length && j < arr2.length) {
      if (arr1[i] < arr2[j]) {
        res.push(arr1[i++])
      } else {
        res.push(arr2[j++])
      }
    }

    if (i < arr1.length) {
      res = res.concat(arr1.slice(i))
    }
    if (j < arr2.length) {
      res = res.concat(arr2.slice(j))
    }

    return res;
  }

  return merge(left, right)
}
```

### 桶排序
按照一定的算法分为n个桶，使数字能较为均匀的分布到n个桶中。
如第1个桶放小于10的，第2个桶放10~20的
然后对每个桶进行排序，最后按顺序合并每个桶得到最终的结果。

### 计数排序
计数排序时特殊的桶排序。
比如说分数是0~100分，那么就分101个桶。

### 基数排序
只能排序非负整数。
比如说十进制的数，先按个位数排序，再按十位数排序。

## 双指针

### 环形链表

https://leetcode.cn/problems/linked-list-cycle-ii/description/
>给定一个链表的头节点  head ，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。
如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。不允许修改 链表。

解答：两个指针，一个指针一次前进1，一个指针1次前进2；如果有环，这两个指针一定会相遇

### 返回arr的最长无重复子数组的长度

https://leetcode.cn/problems/longest-substring-without-repeating-characters/description/
>给定一个字符串 s ，请你找出其中不含有重复字符的最长子串的长度。

解答：两个指针，初始一个指针i指向第0个位置，一个指针j指向第1个位置；如果j指向的字符没有出现过，那么j往右边移动，更新长度，否则，i往右边移动
### 盛水最多的容器

https://leetcode.cn/problems/container-with-most-water/description/

>给定一个长度为 n 的整数数组 height 。有 n 条垂线，第 i 条线的两个端点是 (i, 0) 和 (i, height[i]) 。
找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。
返回容器可以储存的最大水量。

解答：两个指针，一个指向最左边，一个指向最右边；移动矮的那一边（因为如果移动高的，水量一定不会变多）
### 三数之和
https://leetcode.cn/problems/3sum/description/

>给你一个整数数组 nums ，判断是否存在三元组 [nums[i], nums[j], nums[k]] 满足 i != j、i != k 且 j != k ，同时还满足 nums[i] + nums[j] + nums[k] == 0 。请你返回所有和为 0 且不重复的三元组。
注意：答案中不可以包含重复的三元组。

打败5%的写法。。。 todo 优化
```js
var threeSum = function (nums) {

  /* 
    1、从小到大排序
  */
  let res = []
  let hash = {}
  nums.sort((a, b) => a - b)
  for (let i = 0; i < nums.length - 2; i++) {
    for (let j = i + 1; j < nums.length - 1; j++) {
      /* 如果大于0，之后的不可能等于0，直接break */
      let sum = nums[i] + nums[j]
      if(sum>0) break;

      /* 二分 */
      let low = j + 1, high = nums.length - 1
      while(low <= high) {
        let mid = low + ((high - low) >> 1)
        if(sum + nums[mid] === 0) {
          let temp = [nums[i], nums[j], nums[mid]]
          temp.sort((a, b) => a - b)
          /* 用hash保证不重复 */
          const key = `${nums[i]},${nums[j]},${nums[mid]}`
          if (hash[key] === undefined) {
            hash[key] = 1
            res.push(temp)
          }
          break;
        } else if(sum+nums[mid] >0) {
          high = mid - 1
        } else {
          low = mid + 1
        }
      }
    }
  }
  return res;
};
```

=> 双指针写法 时间复杂度：O(n^2)
```js
var threeSum = function (nums) {

  /* 
    1、从小到大排序
    2、第一轮，第一个指针指向0，第2个指针指向1，第3个指针指向最后
            1、 如果和为0，那么第2个指针右移，第3个指针左移
                为了防止重复，在第2个指针的值和前一个相同时，一直右移；
                在第3个指针指向的值和后一个相同时，一直左移；
            2、如果和大于0，那么第3个指针左移
            3、如果和小于0，那么第2个指针右移
            重复，知道第2个指针的位置>= 第3个指针
    3、第一个指针，检查第一个指针，如果和前一个值相同，一直右移；
    4、在第一个指针在没有移动到最后时，一直重复上述过程
  */
  let res = [], len = nums.length
  nums.sort((a, b) => a - b)
  
  let first = 0
  while(first<len) {
    let second = first + 1, last = len - 1
    while(second < last) {
        let sum = nums[first] + nums[second] + nums[last]
        if(sum===0) {
            res.push([nums[first], nums[second], nums[last]])
            second++
            last--
            while(nums[second] === nums[second-1]) {
                second++
            }
            while(nums[last] === nums[last+1]) {
                last--
            }
        } else if(sum>0) {
            last--
        }else {
            second++
        }
    }
    first++
    while(nums[first] === nums[first-1]) {
        first ++
    }
  }
  
  return res;
};
```